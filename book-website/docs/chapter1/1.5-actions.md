---
sidebar_position: 5
title: "Executing Complex Behaviors: Actions"
slug: /chapter1/actions
---

# Executing Complex Behaviors: Actions

For long-running tasks that require continuous feedback and the ability to be preempted or cancelled, ROS 2 **Actions** provide a robust solution. Actions are a higher-level abstraction built on top of topics and services, designed to handle complex behaviors like "drive 10 meters," "pick up object," or "perform a complex manipulation sequence."

Unlike services, which are single request-response, actions allow clients to:
-   Send a **goal** to an action server.
-   Receive continuous **feedback** on the progress of the goal.
-   Receive a final **result** when the goal is completed (or aborted).
-   **Cancel** the goal at any time during its execution.

This makes actions ideal for tasks that take a significant amount of time and where the client needs to monitor progress and potentially intervene.

## Managing Long-Running, Cancellable Tasks

Consider a robot arm that needs to move to a specific position. A service might be suitable if the movement is instantaneous. However, if the movement is slow, involves obstacle avoidance, and might need to be stopped mid-way, an action is the appropriate choice. The action client sends the target position as a goal. The action server provides feedback on the arm's current position as it moves and eventually sends a result indicating whether the target was reached. If an emergency arises, the client can send a cancel request to stop the arm immediately.

## Python Code Example: Action Server/Client

Let's illustrate actions with a simple Python example. We'll create an action server that "counts up" to a given goal and an action client that requests this count, receives feedback, and gets a final result.

First, define the `.action` file for our counting action. Create a file `count_until.action` in an `action` directory within your ROS 2 package:

```
# count_until.action
int32 target_number
int32 period
---
int32 reached_number
---
int32 current_number
```
-   **Goal**: `target_number` (the number to count up to), `period` (delay between counts in milliseconds).
-   **Result**: `reached_number` (the number actually reached).
-   **Feedback**: `current_number` (the current count).

Now, let's implement the server and client.

### The Action Server (`count_until_server.py`)

```python
import time
import rclpy
from rclpy.action import ActionServer, CancelResponse, GoalResponse
from rclpy.node import Node
from your_package_name.action import CountUntil # Assuming 'your_package_name' is your ROS 2 package name

class CountUntilActionServer(Node):
    def __init__(self):
        super().__init__('count_until_action_server')
        self._action_server = ActionServer(
            self,
            CountUntil,
            'count_until',
            self.execute_callback,
            goal_callback=self.goal_callback,
            handle_accepted_callback=self.handle_accepted_callback,
            cancel_callback=self.cancel_callback
        )
        self.get_logger().info('Action server ready.')

    def goal_callback(self, goal_request):
        self.get_logger().info('Received goal request')
        # Validate goal request
        if goal_request.target_number < 0:
            self.get_logger().warn('Goal target_number must be non-negative.')
            return GoalResponse.REJECT
        self.get_logger().info('Goal accepted.')
        return GoalResponse.ACCEPT

    def handle_accepted_callback(self, goal_handle):
        # This callback is called when the goal is accepted and starts processing
        self.get_logger().info('Goal accepted, executing...')
        goal_handle.execute() # Start executing the goal in a separate thread

    def cancel_callback(self, goal_handle):
        self.get_logger().info('Received cancel request')
        return CancelResponse.ACCEPT

    def execute_callback(self, goal_handle):
        self.get_logger().info('Executing goal...')
        feedback_msg = CountUntil.Feedback()
        target_number = goal_handle.request.target_number
        period = goal_handle.request.period / 1000.0 # Convert ms to seconds

        for i in range(target_number + 1):
            if goal_handle.is_cancel_requested:
                goal_handle.canceled()
                self.get_logger().info('Goal canceled.')
                result = CountUntil.Result()
                result.reached_number = i -1 # The number before cancellation
                return result

            feedback_msg.current_number = i
            self.get_logger().info(f'Feedback: {feedback_msg.current_number}')
            goal_handle.publish_feedback(feedback_msg)
            time.sleep(period)

        goal_handle.succeeded()
        result = CountUntil.Result()
        result.reached_number = target_number
        self.get_logger().info(f'Goal succeeded: {result.reached_number}')
        return result

def main(args=None):
    rclpy.init(args=args)
    action_server = CountUntilActionServer()
    rclpy.spin(action_server)
    action_server.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```
-   `ActionServer`: Initializes the action server with the action type `CountUntil` and the action name `count_until`.
-   `goal_callback`: Called when a new goal request is received, allows for validation.
-   `execute_callback`: Contains the logic for processing the goal, publishing feedback, and setting the result.

### The Action Client (`count_until_client.py`)

```python
import sys
import rclpy
from rclpy.action import ActionClient
from rclpy.node import Node
from your_package_name.action import CountUntil # Assuming 'your_package_name' is your ROS 2 package name

class CountUntilActionClient(Node):
    def __init__(self):
        super().__init__('count_until_action_client')
        self._action_client = ActionClient(self, CountUntil, 'count_until')

    def send_goal(self, target_number, period):
        goal_msg = CountUntil.Goal()
        goal_msg.target_number = target_number
        goal_msg.period = period

        self._action_client.wait_for_server()

        self.get_logger().info('Sending goal...')
        self._send_goal_future = self._action_client.send_goal_async(
            goal_msg,
            feedback_callback=self.feedback_callback
        )
        self._send_goal_future.add_done_callback(self.goal_response_callback)

    def goal_response_callback(self, future):
        goal_handle = future.result()
        if not goal_handle.accepted:
            self.get_logger().info('Goal rejected :(')
            return

        self.get_logger().info('Goal accepted :)')
        self._get_result_future = goal_handle.get_result_async()
        self._get_result_future.add_done_callback(self.get_result_callback)

    def get_result_callback(self, future):
        result = future.result().result
        self.get_logger().info(f'Result: Reached number {result.reached_number}')
        rclpy.shutdown() # Shutdown after receiving result

    def feedback_callback(self, feedback_msg):
        self.get_logger().info(f'Feedback: Current number {feedback_msg.feedback.current_number}')

def main(args=None):
    rclpy.init(args=args)
    action_client = CountUntilActionClient()
    if len(sys.argv) != 3:
        action_client.get_logger().info('Usage: ros2 run <your_package_name> count_until_client <target_number> <period_ms>')
        action_client.destroy_node()
        sys.exit(1)

    target_number = int(sys.argv[1])
    period_ms = int(sys.argv[2])
    action_client.send_goal(target_number, period_ms)

    rclpy.spin(action_client) # Keep node alive to process callbacks

if __name__ == '__main__':
    main()
```
-   `ActionClient`: Initializes the action client.
-   `send_goal_async`: Sends the goal and specifies a feedback callback.
-   `goal_response_callback`: Processes the server's response to the goal request (accepted/rejected).
-   `get_result_callback`: Called when the final result is received.
-   `feedback_callback`: Processes feedback messages from the server.

### Running the Example

1.  **Ensure your ROS 2 environment is sourced.**
2.  **Make the scripts executable**: `chmod +x count_until_server.py count_until_client.py`
3.  **Run the action server in one terminal**: `ros2 run <your_package_name> count_until_server`
4.  **Run the action client in another terminal**: `ros2 run <your_package_name> count_until_client 10 500` (counts to 10 with 500ms delay)

You will see the client sending a goal, the server executing it, providing feedback, and finally a result. You can also try pressing `Ctrl+C` in the client terminal while the server is counting to see the cancellation mechanism in action. Actions are a powerful tool for orchestrating complex, long-duration tasks in your robotic system.
