---
sidebar_position: 3
title: "The Heartbeat: Implementing Nodes and Topics"
slug: /chapter1/nodes-topics
---

# The Heartbeat: Implementing Nodes and Topics

At the core of any ROS 2 application are nodes and topics. Nodes are the modular, executable units that perform computation, while topics provide the asynchronous communication mechanism that allows these nodes to exchange data continuously. Together, they form the "heartbeat" of your robotic system, enabling real-time data flow and coordinated behavior.

## Asynchronous Communication: Understanding Nodes

As we discussed, a **Node** in ROS 2 is essentially a process that performs a specific task. Each node is designed to be self-contained and modular, promoting reusability and simplifying debugging. Nodes don't directly "call" each other; instead, they communicate by publishing messages to topics or subscribing to messages from topics. This asynchronous, decoupled communication is a cornerstone of ROS 2's distributed architecture.

Consider a robot with a camera. A `camera_node` might be responsible for capturing images and publishing them. A separate `image_processing_node` might subscribe to these image messages, perform object detection, and then publish the results to another topic. This design ensures that if one node fails, it doesn't necessarily bring down the entire system, and different parts of the robot can be developed and updated independently.

## Continuous Data Streaming: Exploring Topics

**Topics** are the named buses over which nodes exchange messages. They implement a publish/subscribe messaging pattern:
- A **publisher** node sends messages to a specific topic.
- A **subscriber** node receives messages from that same topic.

This one-to-many communication model is ideal for continuous data streams, such as sensor readings (e.g., lidar scans, IMU data), robot odometry, or video feeds. When a publisher sends a message to a topic, all nodes subscribed to that topic will receive a copy of the message.

## Python Code Example: Publisher/Subscriber

Let's illustrate this with a simple Python example. We'll create two nodes: a `talker` (publisher) that sends "Hello ROS!" messages and a `listener` (subscriber) that receives and prints them.

First, create a new ROS 2 package (if you haven't already) to house your nodes. For simplicity, we'll assume you're working within an existing ROS 2 workspace.

### The Publisher (`talker.py`)

Create a file named `talker.py` in your package's `scripts` directory (or wherever you prefer to keep your Python nodes):

```python
import rclpy
from rclpy.node import Node
from std_msgs.msg import String

class Talker(Node):
    def __init__(self):
        super().__init__('talker')
        self.publisher_ = self.create_publisher(String, 'chatter', 10)
        timer_period = 0.5  # seconds
        self.timer = self.create_timer(timer_period, self.timer_callback)
        self.i = 0

    def timer_callback(self):
        msg = String()
        msg.data = f'Hello ROS! {self.i}'
        self.publisher_.publish(msg)
        self.get_logger().info(f'Publishing: "{msg.data}"')
        self.i += 1

def main(args=None):
    rclpy.init(args=args)
    talker = Talker()
    rclpy.spin(talker) # Keep node alive until Ctrl+C
    talker.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

- `rclpy.init(args=args)`: Initializes the ROS 2 Python client library.
- `super().__init__('talker')`: Creates a node named `talker`.
- `self.create_publisher(String, 'chatter', 10)`: Creates a publisher that publishes messages of type `std_msgs.msg.String` to the topic named `chatter` with a queue size of 10.
- `self.create_timer(timer_period, self.timer_callback)`: Sets up a timer to call `timer_callback` every 0.5 seconds.
- `self.publisher_.publish(msg)`: Publishes the message.
- `rclpy.spin(talker)`: Keeps the node alive and processing events.

### The Subscriber (`listener.py`)

Create a file named `listener.py` in the same directory:

```python
import rclpy
from rclpy.node import Node
from std_msgs.msg import String

class Listener(Node):
    def __init__(self):
        super().__init__('listener')
        self.subscription = self.create_subscription(
            String,
            'chatter',
            self.listener_callback,
            10
        )
        self.subscription  # prevent unused variable warning

    def listener_callback(self, msg):
        self.get_logger().info(f'I heard: "{msg.data}"')

def main(args=None):
    rclpy.init(args=args)
    listener = Listener()
    rclpy.spin(listener)
    listener.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

- `self.create_subscription(String, 'chatter', self.listener_callback, 10)`: Creates a subscriber that listens for `String` messages on the `chatter` topic and calls `listener_callback` when a message is received.

### Running the Example

1.  **Ensure your ROS 2 environment is sourced.**
2.  **Make the scripts executable**: `chmod +x talker.py listener.py`
3.  **Run the listener in one terminal**: `ros2 run <your_package_name> listener`
4.  **Run the talker in another terminal**: `ros2 run <your_package_name> talker`

You should see the `talker` node publishing messages and the `listener` node receiving and printing them, demonstrating a fundamental ROS 2 communication pattern.

This publisher-subscriber model is highly flexible and efficient for broadcasting data throughout your robotic system.
