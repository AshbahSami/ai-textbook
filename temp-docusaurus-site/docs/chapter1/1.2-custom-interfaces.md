---
sidebar_position: 2
title: "Designing the Robot’s Vocabulary: Custom Interfaces"
slug: /chapter1/custom-interfaces
---

# Designing the Robot’s Vocabulary: Custom Interfaces

In ROS 2, communication between nodes relies on well-defined message types. While ROS 2 provides a rich set of standard interfaces, you'll often need to define custom message, service, and action types to suit the unique needs of your robotic application. This section will guide you through creating these custom interfaces, which collectively form the "vocabulary" your robot uses to understand and express itself.

## Creating `.msg` files: Defining Data Structures

Message files (`.msg`) are simple text files that define the data structures used for passing information between nodes via topics. They are fundamental for any custom data exchange.

A `.msg` file consists of field type and field name pairs, one per line. Comments start with `#`.

**Example: `MyCustomMessage.msg`**

Let's imagine our robot needs to communicate the status of its grippers, including an integer ID and a boolean indicating if the gripper is open.

```
# MyCustomMessage.msg
int32 gripper_id
bool is_open
string status_message
```

**Understanding the components:**

- `int32`: A standard ROS 2 primitive type for a 32-bit integer.
- `bool`: A boolean type (true/false).
- `string`: A variable-length string.

After defining your `.msg` file, you would typically place it within a `msg` directory inside your ROS 2 package and then configure your `package.xml` and `CMakeLists.txt` to generate the necessary source code for these messages in different programming languages. This process makes `MyCustomMessage` available for use in your C++ or Python ROS 2 nodes.

## Creating `.srv` files: Defining Service Request/Response

Service files (`.srv`) define the request and response structures for ROS 2 services. Services are used for synchronous, request-response communication between nodes.

A `.srv` file is similar to a `.msg` file but is divided into two parts separated by a `---` line: the request definition above the line and the response definition below it.

**Example: `SetLed.srv`**

Consider a service to control an LED on our robot, where we send an LED ID and a boolean for its state, and receive a success status in return.

```
# SetLed.srv
int32 led_id
bool state
---
bool success
```

**Understanding the components:**

- **Request (above `---`)**:
    - `int32 led_id`: The ID of the LED to control.
    - `bool state`: The desired state of the LED (on/off).
- **Response (below `---`)**:
    - `bool success`: Indicates whether the command was successful.

Similar to `.msg` files, `.srv` files are placed in a `srv` directory within a ROS 2 package and require corresponding build system configurations to be usable in your nodes.

## Creating `.action` files: Defining Long-Running Tasks

Action files (`.action`) are used for defining actions, which are a communication pattern for long-running, preemptable tasks. Actions are built upon services and messages, providing feedback during execution and allowing for cancellation.

An `.action` file is composed of three sections separated by `---`: goal, result, and feedback.

**Example: `MoveArm.action`**

Let's define an action for moving a robot arm to a specific position. The goal is the target position, the result is the final position, and the feedback provides updates on the arm's current position.

```
# MoveArm.action
float32 target_position_x
float32 target_position_y
float32 target_position_z
---
float32 final_position_x
float32 final_position_y
float32 final_position_z
---
float32 current_position_x
float32 current_position_y
float32 current_position_z
```

**Understanding the components:**

- **Goal (above first `---`)**:
    - `float32 target_position_x/y/z`: The desired 3D target position for the arm.
- **Result (between `---` lines)**:
    - `float32 final_position_x/y/z`: The final 3D position of the arm once the action is complete.
- **Feedback (below second `---`)**:
    - `float32 current_position_x/y/z`: The arm's current 3D position, provided periodically during execution.

`.action` files are placed in an `action` directory within your ROS 2 package and, like messages and services, require proper build system integration to generate the necessary client and server interfaces.

By mastering custom interfaces, you gain the ability to precisely define the data and communication patterns essential for building sophisticated and tailored robotic applications with ROS 2.
