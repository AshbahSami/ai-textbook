---
sidebar_position: 6
title: "Assembling the Nervous System: Packages, Launch Files, and QoS"
slug: /chapter1/packages-launch-qos
---

# Assembling the Nervous System: Packages, Launch Files, and QoS

Building a complex robotic system with ROS 2 involves more than just writing individual nodes. It requires organizing your code, automating the startup of multiple components, and ensuring reliable communication under various conditions. This section covers three crucial aspects: ROS 2 packages for code organization, launch files for orchestrating multiple nodes, and Quality of Service (QoS) settings for fine-tuning communication.

## Creating a ROS 2 Package

A ROS 2 **package** is the fundamental unit for organizing software. It typically contains source code, message/service/action definitions, configuration files, and launch files, all related to a specific piece of functionality. Creating packages helps in managing dependencies, distributing code, and adhering to standard ROS 2 development practices.

To create a new package, you use the `ros2 pkg create` command. For example, to create a Python package named `my_robot_controller` with `rclpy` (ROS Client Library for Python) dependencies:

```bash
ros2 pkg create --build-type ament_python my_robot_controller --dependencies rclpy
```

This command creates a directory structure for `my_robot_controller`, including `package.xml` (metadata) and `setup.py` (for Python package configuration). You would then place your Python nodes (`.py` files) and custom interface definitions (`.msg`, `.srv`, `.action` files) within this package.

## Writing a Python Launch File

As your robotic system grows, you'll have many nodes that need to start together, often with specific arguments or in a particular order. **Launch files** are XML or Python scripts that allow you to define and execute a collection of nodes and other commands. Python launch files are generally preferred for their flexibility and readability.

A launch file can:
-   Start multiple nodes.
-   Set parameters for nodes.
-   Remap topic names.
-   Include other launch files.
-   Execute shell commands.

**Example: `my_robot_launch.py`**

Let's say you have a `sensor_node` and a `processing_node` within your `my_robot_controller` package that you want to launch together.

```python
from launch import LaunchDescription
from launch_ros.actions import Node

def generate_launch_description():
    return LaunchDescription([
        Node(
            package='my_robot_controller',
            executable='sensor_node',
            name='robot_sensor',
            output='screen',
            emulate_tty=True,
            parameters=[
                {'sensor_topic': '/robot/data'},
                {'frame_id': 'base_link'}
            ]
        ),
        Node(
            package='my_robot_controller',
            executable='processing_node',
            name='data_processor',
            output='screen',
            emulate_tty=True,
            parameters=[
                {'input_topic': '/robot/data'},
                {'output_topic': '/robot/processed_data'}
            ]
        )
    ])
```

-   `LaunchDescription`: The root element of a launch file.
-   `Node`: Represents a ROS 2 node to be launched.
    -   `package`: The ROS 2 package the node belongs to.
    -   `executable`: The name of the executable for the node.
    -   `name`: The name assigned to this specific instance of the node.
    -   `output='screen'`: Directs node output to the console.
    -   `emulate_tty=True`: Ensures proper console output buffering.
    -   `parameters`: A list of dictionaries or YAML files to set node parameters.

To run this launch file:

```bash
ros2 launch my_robot_controller my_robot_launch.py
```

Launch files are indispensable for managing the complexity of multi-node ROS 2 applications, enabling consistent and automated startup routines.

## Understanding Quality of Service (QoS)

**Quality of Service (QoS)** policies in ROS 2 allow you to configure the communication behavior of topics, services, and actions. QoS settings are crucial for ensuring that your data communication meets the specific requirements of your application, especially in scenarios involving unreliable networks, real-time constraints, or large data volumes.

Key QoS policies include:

-   **History**: How messages are stored (e.g., `keep_last` for a fixed number, `keep_all` for all messages up to a limit).
-   **Depth**: Used with `keep_last` history to specify the number of messages to keep.
-   **Reliability**: Whether message delivery is guaranteed (`reliable`) or best-effort (`best_effort`). `reliable` is suitable for critical data, `best_effort` for high-frequency, non-critical data (like video streams where dropping a few frames is acceptable).
-   **Durability**: Whether messages are transient (`transient_local`) or volatile (`volatile`). `transient_local` means new subscribers receive the last published message, while `volatile` means they only receive messages published after they subscribe.
-   **Liveliness**: How the system detects if a publisher is still active (e.g., `automatic`, `manual_by_topic`).

You can specify QoS settings when creating publishers and subscribers in your nodes:

```python
import rclpy
from rclpy.node import Node
from rclpy.qos import QoSProfile, ReliabilityPolicy, HistoryPolicy, DurabilityPolicy
from std_msgs.msg import String

class MyPublisher(Node):
    def __init__(self):
        super().__init__('my_publisher')
        qos_profile = QoSProfile(
            reliability=ReliabilityPolicy.RELIABLE,
            history=HistoryPolicy.KEEP_LAST,
            depth=10,
            durability=DurabilityPolicy.TRANSIENT_LOCAL
        )
        self.publisher_ = self.create_publisher(String, 'my_topic', qos_profile)
        timer_period = 1.0
        self.timer = self.create_timer(timer_period, self.timer_callback)
        self.i = 0

    def timer_callback(self):
        msg = String()
        msg.data = f'Hello from QoS {self.i}'
        self.publisher_.publish(msg)
        self.get_logger().info(f'Publishing: "{msg.data}"')
        self.i += 1

def main(args=None):
    rclpy.init(args=args)
    my_publisher = MyPublisher()
    rclpy.spin(my_publisher)
    my_publisher.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

By carefully configuring QoS policies, you can optimize your ROS 2 communication for performance, robustness, and specific application needs.
